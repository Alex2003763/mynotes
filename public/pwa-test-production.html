<!DOCTYPE html>
<html>
<head>
    <title>PWA ç”Ÿç”¢ç’°å¢ƒæ¸¬è©¦</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { font-family: system-ui; padding: 20px; line-height: 1.6; }
        .result { margin: 10px 0; padding: 10px; border-radius: 5px; }
        .success { background: #d4edda; border: 1px solid #c3e6cb; color: #155724; }
        .error { background: #f8d7da; border: 1px solid #f5c6cb; color: #721c24; }
        .info { background: #d1ecf1; border: 1px solid #bee5eb; color: #0c5460; }
        .warning { background: #fff3cd; border: 1px solid #ffeaa7; color: #856404; }
        button { background: #007bff; color: white; border: none; padding: 10px 20px; margin: 5px; border-radius: 5px; cursor: pointer; }
        button:hover { background: #0056b3; }
        .install-btn { background: #28a745; }
        .install-btn:hover { background: #1e7e34; }
        .update-btn { background: #ffc107; color: #000; }
        .update-btn:hover { background: #e0a800; }
    </style>
</head>
<body>
    <h1>ğŸ”§ PWA ç”Ÿç”¢ç’°å¢ƒåŠŸèƒ½æ¸¬è©¦</h1>
    <div id="results"></div>
    
    <div style="margin-top: 20px;">
        <button id="installBtn" class="install-btn" style="display: none;">ğŸ“± å®‰è£ PWA</button>
        <button id="updateBtn" class="update-btn" style="display: none;">ğŸ”„ æ›´æ–°æ‡‰ç”¨ç¨‹å¼</button>
        <button onclick="location.reload()">ğŸ”„ é‡æ–°æ•´ç†é é¢</button>
        <button onclick="testOffline()">ğŸ“´ æ¸¬è©¦é›¢ç·šæ¨¡æ“¬</button>
        <button onclick="clearCaches()">ğŸ—‘ï¸ æ¸…é™¤æ‰€æœ‰å¿«å–</button>
    </div>
    
    <div style="margin-top: 20px;">
        <h3>å¿«é€Ÿæ¸¬è©¦æŒ‡å—ï¼š</h3>
        <ol>
            <li>ç¢ºèªæ‰€æœ‰é …ç›®é¡¯ç¤º âœ… æˆåŠŸç‹€æ…‹</li>
            <li>å¦‚æœå‡ºç¾å®‰è£æŒ‰éˆ•ï¼Œé»æ“Šæ¸¬è©¦ PWA å®‰è£</li>
            <li>é–‹å•Ÿé–‹ç™¼è€…å·¥å…· â†’ Application â†’ Service Workers æª¢æŸ¥ç‹€æ…‹</li>
            <li>åˆ‡æ›åˆ° Network æ¨™ç±¤ï¼Œå‹¾é¸ "Offline" æ¸¬è©¦é›¢ç·šåŠŸèƒ½</li>
            <li>åœ¨æ‰‹æ©Ÿä¸Šæ¸¬è©¦ï¼šç€è¦½å™¨é¸å–® â†’ "åŠ åˆ°ä¸»ç•«é¢"</li>
        </ol>
    </div>
    
    <script>
        const results = document.getElementById('results');
        let installPrompt = null;
        let updateSW = null;
        
        function log(message, type = 'info') {
            const div = document.createElement('div');
            div.className = `result ${type}`;
            div.innerHTML = message;
            results.appendChild(div);
        }
        
        function clear() {
            results.innerHTML = '';
        }
        
        async function runTests() {
            clear();
            log('ğŸš€ é–‹å§‹ PWA åŠŸèƒ½æ¸¬è©¦...', 'info');
            
            // 1. Service Worker æ¸¬è©¦
            if ('serviceWorker' in navigator) {
                log('âœ… Service Worker API æ”¯æ´', 'success');
                
                try {
                    const registrations = await navigator.serviceWorker.getRegistrations();
                    if (registrations.length > 0) {
                        log(`âœ… æ‰¾åˆ° ${registrations.length} å€‹å·²è¨»å†Šçš„ Service Worker`, 'success');
                        
                        registrations.forEach((reg, i) => {
                            const state = reg.active ? reg.active.state : 'æœªçŸ¥';
                            log(`   SW ${i+1}: ${reg.scope} (ç‹€æ…‹: ${state})`, 'info');
                        });
                    } else {
                        log('âŒ æ²’æœ‰æ‰¾åˆ°å·²è¨»å†Šçš„ Service Worker', 'error');
                    }
                    
                    if (navigator.serviceWorker.controller) {
                        log('âœ… ç›®å‰é é¢æœ‰ Service Worker æ§åˆ¶', 'success');
                    } else {
                        log('âŒ ç›®å‰é é¢æ²’æœ‰ Service Worker æ§åˆ¶', 'error');
                    }
                } catch (error) {
                    log(`âŒ Service Worker æª¢æŸ¥å¤±æ•—: ${error.message}`, 'error');
                }
            } else {
                log('âŒ ç€è¦½å™¨ä¸æ”¯æ´ Service Worker', 'error');
            }
            
            // 2. Manifest æ¸¬è©¦
            const manifestLink = document.querySelector('link[rel="manifest"]');
            if (manifestLink) {
                log(`âœ… æ‰¾åˆ° manifest é€£çµ: ${manifestLink.href}`, 'success');
                
                try {
                    const response = await fetch(manifestLink.href);
                    if (response.ok) {
                        const manifest = await response.json();
                        log(`âœ… Manifest è¼‰å…¥æˆåŠŸ: ${manifest.name || manifest.short_name}`, 'success');
                        log(`   æè¿°: ${manifest.description || 'ç„¡'}`, 'info');
                        log(`   åœ–ç¤º: ${manifest.icons ? manifest.icons.length : 0} å€‹`, 'info');
                        log(`   é¡¯ç¤ºæ¨¡å¼: ${manifest.display || 'æœªè¨­å®š'}`, 'info');
                    } else {
                        throw new Error(`HTTP ${response.status}`);
                    }
                } catch (error) {
                    log(`âŒ Manifest è¼‰å…¥å¤±æ•—: ${error.message}`, 'error');
                }
            } else {
                log('âŒ æ²’æœ‰æ‰¾åˆ° manifest é€£çµ', 'error');
            }
            
            // 3. Cache API æ¸¬è©¦
            if ('caches' in window) {
                log('âœ… Cache API æ”¯æ´', 'success');
                
                try {
                    const cacheNames = await caches.keys();
                    if (cacheNames.length > 0) {
                        log(`âœ… æ‰¾åˆ° ${cacheNames.length} å€‹å¿«å–`, 'success');
                        
                        for (const cacheName of cacheNames) {
                            const cache = await caches.open(cacheName);
                            const keys = await cache.keys();
                            log(`   ğŸ“¦ ${cacheName}: ${keys.length} å€‹é …ç›®`, 'info');
                        }
                    } else {
                        log('âš ï¸ æ²’æœ‰æ‰¾åˆ°ä»»ä½•å¿«å–', 'warning');
                    }
                } catch (error) {
                    log(`âŒ å¿«å–æª¢æŸ¥å¤±æ•—: ${error.message}`, 'error');
                }
            } else {
                log('âŒ ç€è¦½å™¨ä¸æ”¯æ´ Cache API', 'error');
            }
            
            // 4. å®‰è£ç‹€æ…‹æª¢æŸ¥
            if (window.matchMedia && window.matchMedia('(display-mode: standalone)').matches) {
                log('âœ… æ‡‰ç”¨ç¨‹å¼ä»¥ç¨ç«‹æ¨¡å¼é‹è¡Œï¼ˆå·²å®‰è£ç‚º PWAï¼‰', 'success');
            } else {
                log('ğŸ“± æ‡‰ç”¨ç¨‹å¼æœªä»¥ç¨ç«‹æ¨¡å¼é‹è¡Œï¼ˆå¯å®‰è£ç‚º PWAï¼‰', 'info');
            }
            
            // 5. ç¶²è·¯ç‹€æ…‹
            const onlineStatus = navigator.onLine ? 'ç·šä¸Š' : 'é›¢ç·š';
            const statusType = navigator.onLine ? 'success' : 'warning';
            log(`ğŸŒ ç¶²è·¯ç‹€æ…‹: ${onlineStatus}`, statusType);
            
            // 6. æ¨é€é€šçŸ¥æ”¯æ´
            if ('Notification' in window) {
                log(`ğŸ”” æ¨é€é€šçŸ¥æ”¯æ´: ${Notification.permission}`, 'info');
            } else {
                log('âŒ ç€è¦½å™¨ä¸æ”¯æ´æ¨é€é€šçŸ¥', 'error');
            }
            
            log('âœ… PWA åŠŸèƒ½æ¸¬è©¦å®Œæˆï¼', 'success');
        }
        
        // PWA å®‰è£æç¤ºè™•ç†
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            installPrompt = e;
            document.getElementById('installBtn').style.display = 'inline-block';
            log('âœ… PWA å®‰è£æç¤ºå·²æº–å‚™å°±ç·’', 'success');
        });
        
        document.getElementById('installBtn').addEventListener('click', async () => {
            if (installPrompt) {
                installPrompt.prompt();
                const result = await installPrompt.userChoice;
                if (result.outcome === 'accepted') {
                    log('âœ… ç”¨æˆ¶æ¥å—äº† PWA å®‰è£', 'success');
                } else {
                    log('âŒ ç”¨æˆ¶æ‹’çµ•äº† PWA å®‰è£', 'warning');
                }
                installPrompt = null;
                document.getElementById('installBtn').style.display = 'none';
            }
        });
        
        // Service Worker æ›´æ–°è™•ç†
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.addEventListener('message', (event) => {
                if (event.data && event.data.type === 'SKIP_WAITING') {
                    document.getElementById('updateBtn').style.display = 'inline-block';
                }
            });
        }
        
        document.getElementById('updateBtn').addEventListener('click', () => {
            if (updateSW) {
                updateSW();
                document.getElementById('updateBtn').style.display = 'none';
                log('ğŸ”„ æ‡‰ç”¨ç¨‹å¼æ›´æ–°ä¸­...', 'info');
            }
        });
        
        // æ¸¬è©¦åŠŸèƒ½
        async function testOffline() {
            log('ğŸ“´ æ¨¡æ“¬é›¢ç·šæ¸¬è©¦ï¼ˆè«‹åœ¨é–‹ç™¼è€…å·¥å…·ä¸­æ‰‹å‹•åˆ‡æ›åˆ°é›¢ç·šæ¨¡å¼ï¼‰', 'info');
            
            // å˜—è©¦è¼‰å…¥ä¸€å€‹ä¸å­˜åœ¨çš„è³‡æºä¾†æ¸¬è©¦é›¢ç·šè™•ç†
            try {
                const response = await fetch('/test-offline-' + Date.now());
                if (response.ok) {
                    log('âš ï¸ æ„å¤–æˆåŠŸ - å¯èƒ½æ²’æœ‰æ­£ç¢ºè¨­å®šé›¢ç·šæ¨¡å¼', 'warning');
                } else {
                    log('âœ… é›¢ç·šè«‹æ±‚æ­£ç¢ºè™•ç†', 'success');
                }
            } catch (error) {
                log('âœ… é›¢ç·šè«‹æ±‚è¢«æ­£ç¢ºæ””æˆª', 'success');
            }
        }
        
        async function clearCaches() {
            if ('caches' in window) {
                const cacheNames = await caches.keys();
                await Promise.all(cacheNames.map(name => caches.delete(name)));
                log('ğŸ—‘ï¸ æ‰€æœ‰å¿«å–å·²æ¸…é™¤', 'info');
                
                // é‡æ–°è¨»å†Š Service Worker
                if ('serviceWorker' in navigator) {
                    const registrations = await navigator.serviceWorker.getRegistrations();
                    await Promise.all(registrations.map(reg => reg.unregister()));
                    log('ğŸ—‘ï¸ Service Worker å·²å–æ¶ˆè¨»å†Š', 'info');
                }
                
                log('ğŸ”„ å»ºè­°é‡æ–°æ•´ç†é é¢ä»¥é‡æ–°åˆå§‹åŒ–', 'warning');
            }
        }
        
        // ç›£è½ç¶²è·¯ç‹€æ…‹è®ŠåŒ–
        window.addEventListener('online', () => log('ğŸŒ ç¶²è·¯é€£ç·šå·²æ¢å¾©', 'success'));
        window.addEventListener('offline', () => log('ğŸ“´ ç¶²è·¯é€£ç·šå·²ä¸­æ–·', 'warning'));
        
        // è‡ªå‹•åŸ·è¡Œæ¸¬è©¦
        window.addEventListener('load', runTests);
    </script>
</body>
</html>